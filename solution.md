
```C++
__kernel do_some_work()
{
    // assert(get_group_size() == [256, 1, 1]);
    __local disjoint_set = ...;

    //
    // Пусть control_field это наше подобие мьютекса.
    //
    // Пусть самый старший бит этого числа будет значить, пишет ли
    // кто либо сейчас в нашу структуру данных.
    // 
    // Пусть младшие 16 бит будут означать количество читателей, которые 
    // в текущий момент времени работают с нашей структурой данных.
    //
    // Пусть оставшиеся 15 бит будут означать количество писателей, которые
    // хотят начать писать в нашу структуру данных.
    //
    __local volatile unsigned control_field = 0;

    for (int iters = 0; iters < 100; ++iters) { 
        if (some_random_predicat(...)) { 
            //
            // Допустим, для каких-то потоков этот предикат выполнился.
            //
            // Тогда вначале попробуем добавить себя в список желающих писать
            // в структуру данных
            //
            while (true) {
                // Считаем текущее значение control_field
                unsigned expected = control_field;

                // Обозначим для каждого потока, выполнившего предикат,
                // его желание писать в структуру данных.
                unsigned desired = expected + (1 << 16);

                // После успешной замены control_field, всем потокам-читателям станет
                // известно о намерениях писать в структуру данных.
                if (expected == atomic_cmpxchg(&control_field, expected, desired)) {

                    // Если текущий поток добавил себя в список, то он может
                    // закончить цикл, но ему все еще придется дождаться других
                    // потоков ворпа, желающих что-то писать
                    break;
                }
            }
            
            //
            // Теперь, когда поток, желающий писать, заявил о своих намерениях,
            // ему необходимо стать писателем и выполнить необходимую работу.
            //
            while(true) {
                // Снова считаем текущее значение control_field
                unsigned expected = control_field;

                //
                // Каждым потоком, желающим писать, но не пишущим, дождемся,
                // пока структура данных не будет свободна. 
                //
                // То есть, проверим флаг наличия текущего писателя и 
                // количество текущих читателей.
                //
                if ((expected & 0x8000ffff) == 0) {

                    // Если оказалось, что сейчас писателей нет, и никто
                    // сейчас не читает, то попытаемся
                    // занять место писателя, попутно убрав себя из желающих писать
                    unsigned desired = expected + (1 << 31) - (1 << 16);

                    // Если у нас получилось стать писателем, то делаем свою работу
                    if (expected == atomic_cmpxchg(&control_field, expected, desired)) {
                        union(disjoint_set, ...);  
                        
                        // Освободим теперь место писателя
                        while (true) {
                            unsigned expected = control_field;
                            unsigned desired = expected - (1 << 31);
                            if (expected == atomic_cmpxchg(&control_field, expected, desired)) {
                                break;
                            }
                        }

                        // Закончим работу текущим потоком
                        break;
                    }
                }
            }
        }

        //
        // Добравшись до этого места, все потоки ворпа захотят 
        // прочитать что-то из структуры данных
        //
        // Сделаем небольшую оптимизацию - вместо того, чтобы каждым потоком
        // заявлять о чтении из структуры данных, выделим в каждом ворпе ответственного,
        // который сделает заявку на всех.
        //
        if (get_local_id(0) % WARP_SIZE == 0) {

            //
            // Будем пытаться обозначить свои намерения читать
            //
            while (true) {
                // Считаем текущее значение control_field
                unsigned expected = control_field;

                //
                // Проверим, что в структуру данных никто не пишет и никто
                // не хочет писать
                //
                if (expected & 0xffff0000 == 0) {
                    //
                    // Попытаемся выставить WARP_SIZE намерений на чтение
                    //
                    unsigned desired = expected + WARP_SIZE;
                    if (expected == atomic_cmpxchg(&control_field, expected, desired)) {
                        // В случае успеха отправимся читать всеми потоками ворпа
                        break;
                    }
                }
            }
        }

        tmp = get(disjoint_set, ...);

        //
        // Мастер-потоком каждого ворпа объявим о завершении чтения
        //
        if (get_local_id(0) % WARP_SIZE == 0) {
            while (true) {
                unsigned expected = control_field;
                unsigned desired = expected - WARP_SIZE;
                if (expected == atomic_cmpxchg(&control_field, expected, desired)) {
                    break;
                }
            }
        }
    }
}
```
